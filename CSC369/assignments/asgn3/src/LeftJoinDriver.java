import java.io.IOException;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.NullWritable;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.input.MultipleInputs;
import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;
import org.apache.log4j.Logger;

public class LeftJoinDriver extends Configured implements Tool {

    private static Logger THE_LOGGER = Logger.getLogger(LeftJoinDriver.class);
    private static Path transactions;
    private static Path users;
    private static Path output;
    private static Path middle1;
    private static Path middle2;

    public boolean runJob1() throws IOException, InterruptedException, ClassNotFoundException {

        Job job1 = Job.getInstance();

        job1.setJobName("Phase-1: Left Outer Join");
	job1.setJarByClass(LeftJoinDriver.class);
        // "secondary sort" is handled by setting the following 3 plug-ins:
        // 1. how the mapper generated keys will be partitioned
        job1.setPartitionerClass(LeftJoinPartitioner.class);

        // 2. how the natural keys (generated by mappers) will be grouped
        job1.setGroupingComparatorClass(LeftJoinGroupComparator.class);

        // 3. how PairOfStrings will be sorted
        //job.setSortComparatorClass(PairOfStrings.Comparator.class);
        job1.setReducerClass(LeftJoinReducer.class);

        job1.setOutputKeyClass(Text.class);
        job1.setOutputValueClass(Text.class);
        //  job.setOutputFormatClass(SequenceFileOutputFormat.class);

        // define multiple mappers: one for users and one for transactions
        Class.forName("LeftJoinTransactionMapper");
	Class.forName("LeftJoinUserMapper");
	MultipleInputs.addInputPath(job1, transactions, TextInputFormat.class, LeftJoinTransactionMapper.class);
        MultipleInputs.addInputPath(job1, users, TextInputFormat.class, LeftJoinUserMapper.class);
        job1.setMapOutputKeyClass(PairOfStrings.class);
        job1.setMapOutputValueClass(PairOfStrings.class);
        FileOutputFormat.setOutputPath(job1, middle1);

        boolean status = job1.waitForCompletion(true);

        THE_LOGGER.info("run(): status=" + status);
        return status;
    }

    public boolean runJob2() throws IOException, InterruptedException, ClassNotFoundException {
        Job job2 = Job.getInstance();

        job2.setJobName("Phase-2: Duplicate Elimination");
	job2.setJarByClass(LeftJoinDriver.class);
        job2.setMapperClass(DuplicateEliminateMapper.class);
        job2.setReducerClass(DuplicateEliminateReducer.class);

        job2.setOutputKeyClass(Text.class);
        job2.setOutputValueClass(NullWritable.class);

        job2.setMapOutputKeyClass(PairOfStrings.class);
        job2.setMapOutputValueClass(NullWritable.class);

        FileInputFormat.setInputPaths(job2, middle1);
        FileOutputFormat.setOutputPath(job2, middle2);

        boolean status = job2.waitForCompletion(true);

        THE_LOGGER.info("run(): status=" + status);

        return status;
    }

    public boolean runJob3() throws IOException, InterruptedException, ClassNotFoundException{
    	Job job3 = Job.getInstance();

        job3.setJobName("Phase-3: Counting");
	job3.setJarByClass(LeftJoinDriver.class);
        job3.setMapperClass(CountMapper.class);
        job3.setReducerClass(CountReducer.class);

        job3.setOutputKeyClass(Text.class);
        job3.setOutputValueClass(IntWritable.class);

        job3.setMapOutputKeyClass(Text.class);
        job3.setMapOutputValueClass(IntWritable.class);

        FileInputFormat.setInputPaths(job3, middle2);
        FileOutputFormat.setOutputPath(job3, output);

        boolean status = job3.waitForCompletion(true);

        THE_LOGGER.info("run(): status=" + status);

        return status;
    }

    public int run(String[] args) throws Exception {
	transactions = new Path(args[0]);
	users = new Path(args[1]);
	output = new Path(args[2]);
	middle1 = new Path(args[3]);
	middle2 = new Path(args[4]);
        return (runJob1()&&runJob2()&&runJob3())? 0 : 1;
    }

    public static void main(String[] args) throws Exception {	
        int returnStatus = ToolRunner.run(new LeftJoinDriver(), args);
        System.exit(returnStatus);
    }

}
