<!doctype html>
<html>
<head>
   <meta charset="utf-8"/>
   <title>Lab 3, CSC/CPE 203</title>
   <link rel="stylesheet" href="../../lib/assignment.css" type="text/css">
</head>

<body>
<div class="container">
  <div class="boxed">

  <div class="header">  <h1>Lab 3, CSC/CPE 203 - static methods v. instance methods</h1></div>

<p>
<div class="header">
<h2>Orientation</h2>
</div>

<p>
This lab explores the difference between static methods and instance 
methods in Java.  Both are useful, but as we develop more complex code, 
there are many of reasons to prefer instance methods, where the
computation is associated with a specific instance of an object.  This
way of doing computation, where objects perform actions, is one of the
foundational differences when we do object-oriented programming.
</p>

<div class="header">
<h2>Objectives</h2>
</div>

<ul>
<li>In part 1, to write non-OO, static methods that can compute the perimeter 
    of three different types of geometric shapes (Circle, Rectangle and 
    Polygon)
<li>In part 2, to re-write perimiter as an instance method.  It's useful to
    think of this as the object "knowing how to calculate its perimeter."
<li>To write a static method to compare the perimeters of different 
    objects (part 1 & 2)
<li>To to write your own test cases that create shape objects,
    test the computation of their perimeter, and test the computation 
    of comparison of their perimeters (part 1 & 2)
</ul>


<div class="header">
<h2>Resources</h2>
</div>

<p>
The same Testy library as before.
</p>

<div class="header">
<h2>Part 1: Classes and Overloaded Methods</h2>
</div>

<p>
In the provided <code>part1</code> subdirectory, implement the following
classes to these requirements:
</p>

<ul>
   <li><p>Each instance variable must be <code>private</code> and
      <code>final</code>.</p></li>
   <li><p>Provide the appropriate "accessor"/"getter" methods for the
      instance variables.  See <code>PartOneTestCases.java</code> for
      their names.</p></li>
   <li><p>You may add methods beyond those required, but any such
      additional method must be <code>private</code>.</p></li>
</ul>

<p>
Do not just mechanically apply these rules only to satisfy
a style checker in order to complete the lab.  Instead, consider the
reasons for these rules, what violating them would expose to the user/client
of the corresponding class, and what following them guarantees to you,
the implementer.  This would be a good thing to discuss with your neighbors
in the lab.
</p>

<div class="header">
<h3>Classes</h3>
</div>

<p>
The following assumes your two-dimensional <code>Point</code> implementation
from the previous lab.  Copy your <code>Point.java</code> into the working
directory.
</p>

<p>Implement these classes.</p>

<ul>
   <li><code>Circle.java</code> represents a circle given a
      <code>Point</code> center and a <code>double</code> radius.
      There must be a two-argument constructor taking a Point and a double,
      in that order.
   <li><code>Rectangle.java</code> represents an axis-aligned rectangle
      given a <code>Point</code> top-left and a <code>Point</code>
      bottom-right.  The constructor shall take two points, in that order.
   <li><code>Polygon.java</code> represents a polygon given
      <code>List&lt;Point&gt;</code> points.  There shall be a one-argument
      constructor taking a list of points.
</ul>

<p>
<b>Note that as your implementation will be tested with an 
automated test program.</b>  <code>PartOneTestCases.java</code> will
give you some idea of the kinds of tests that will be automatically
run.  You may save some time by checking exactly
what expected method names it's looking for.  Search for
expectedMethodNames in the appropriate test methods.
</p>

<div class="header">
<h3>Overloaded Method</h3>
</div>

<p>
Define a <code>Util</code> class with three <code>static</code>
<code>perimeter</code> methods.  Each such method takes, as its single
parameter, one of the classes defined in the previous step (i.e., there
is one <code>perimeter</code> method that takes a <code>Circle</code>,
one <code>perimeter</code> method that takes a <code>Polygon</code>,
etc.).  Each returns the perimeter of the object as a <code>double</code>.
</p>

<p>
You can assume that all constructors will create correct closed
shapes.
</p>

<p>
A method like <code>perimeter</code> is considered "overloaded"
because is a separate definition for different parameter types.  
Another way of thinking about this is to consider the argument types
to be part of how the compiler identifies a method.  The combination
of method name and parameter types is called a "method signature."
</p>

<p>
To call a static method like these, you use the name of the class,
followed by the method name.  For example, you can invoke
<code>Util.perimeter(Circle)</code> like this:
<blockquote><pre>
Util.perimeter(new Circle(new Point(0, 0), 1.0));
</pre></blockquote>
</p>

<p>
<span class="warning">Deeper Understanding:</span> How does the Java
implementation know which version of <code>perimeter </code> to use when the
method is invoked?  In the case of static methods, this is done purley
by the compiler.  How?  If the answer is not apparent, then
think about the different method invocations and speak with those around you.
If the answer seems obvious, then hold on to that belief for the next few weeks
to see if it continues to work.
</p>

<div class="header">
<h3>Methods in Action</h3>
</div>

<p>
Define a <code>Bigger</code> class with one
<code>static whichIsBigger</code> method.  This helper method will take
three parameters, in this order: a <code>Circle</code>, a 
<code>Rectangle</code>, and  a </code>Polygon</code>.  It will
return a <code>double</code> representing the largest perimeter of the
three objects. Write a test case that uses this method to determine 
which is the largest between:
</p>

<ol>
<li> a cirle centered at {1.0, 1.0} with radius of 2.0 
<li> a rectangle with the corners {-1.0, 2.0} and {1.0, -1.6}
<li> a polygon defined by {0, 0}, {3, 1}, {1, 4}, and {-1, 4}
</ol>

<p>
You may want to test your perimeter computations before testing
<code>whichIsBigger()</code>.
</p>

<div class="header">
<h3>Tests</h3>
</div>

<p>Write at least one test for each of these operations.  Add your
tests to the provided <code>PartOneTestCases.java</code> file.</p>

<p>
You are expected to write at least one test case for each perimeter and one
test case for whichIsBigger.  
That means you must submit at least 8 tests, including the ones
that are already present.
</p>

<p>
Helper: here is an example of testing the perimeter for a polygon:<br>

<PRE>
   public void testPerimPoly() {
        List&lt;Point&gt;points = new ArrayList&lt;Point &gt;(); 
        points.add(new Point(0, 0));
        points.add(new Point(3,0));
        points.add(new Point(0,4));
        double d = Util.perimeter(new Polygon(points));
        assertEquals(12.0, d, DELTA);
   }<br>
</PRE>

<div class="header">
<h2>Part 2: Methods</h2>
</div>

<p>Copy your source files files from <code>part1</code> into 
<code>part2</code>, with the exception of the test file.

<p>The definition of <code>perimeter</code> in the first part of this
lab does not follow an object-oriented style.  This part of the lab
asks that you make a few modifications to improve the code.  Further
impoovements are possible; we'll learn how later in the course.
</p>

<p>
From <code>Util.java</code>, move each <code>perimeter</code> method
into the appropriate class, as an instance method.
We think of this as each object knowing how to to compute its own perimeter.
Since an instance method is invoked on an object, and that object is known to
the method, <code>perimeter</code> will no longer need to take a parameter.
it acts on <code>this</code>, which refers to the object on which the
method was invoked.  Once you're done moving functions, <code>Util.java</code> 
should be empty, so you can remove it.
</p>

<p>
Be sure to also copy over the <code>Bigger</code> class and revise it to 
use your new instance methods.
<i>Take a moment... do you like one style over the other?</i>
</p>

<div class="header">
<h3>Tests</h3>
</div>

<p>Add tests to the provided <code>PartTwoTestCases.java</code> file.
This is another place you'll be able to see the effect of having the 
methods associated with the objects, versus static methods that are part
of some other class.
Again, there should be an added test for each of the types of perimeters
and a test of <code>whichIsBigger()</code>.  Can you challenge your neighbor 
with new perimeters?

<i>Reflect, do you like one style over the other?</i>
</p>

<div class="header">
<h2>Submission</h2>
</div>

<p>
Submit your code for Parts 1 and 2 in <code>turninXXX/lab03</code> to GitHub by midnight on the due date.  
If you'd like to submit the lab one day late with a penalty of 5%, 
add a file called <code>late_5_percent_off.txt</code> to the 
<code>lab03</code> directory.  If you'd like to submit the lab two 
days late with a penalty of 15%, add a file called
<code>late_15_percent_off.txt</code> to the <code>lab03</code>
directory.  Make sure you add and push the late file.
<p>
After your code is working and submitted,
check you submission using the <code>checkgit</code> command on the
unix server.  If the autograder can't compile your lab for a reason that
is caught by <code>checkgit</code>, you will get a zero on the lab.  To
check your submission, on a Unix server type:
<blockquote><pre>checkgit &lt;git-login> 203 lab03</pre></blockquote>
<p>
If it works, you will see the message "** Tests Passed **".  If not,
you will see some kind of error message.  The error message might not tell
you exactly what you need to change, but it should give an indication as
to what is wrong.


</div>
</div>
</body>
</html>
